// Code generated by "enumer -transform lower -trimprefix Fmt -type Op,Fmt ."; DO NOT EDIT.

package rj32

import (
	"fmt"
	"strings"
)

const _OpName = "nopretserrorhaltrcsrwcsrmoveloadcimmjumpcallsysloadstoreloadbstorebaddsubaddcsubcxorandorshlshrasrifeqifneifltifgeifloifhs"

var _OpIndex = [...]uint8{0, 3, 7, 12, 16, 20, 24, 28, 33, 36, 40, 44, 47, 51, 56, 61, 67, 70, 73, 77, 81, 84, 87, 89, 92, 95, 98, 102, 106, 110, 114, 118, 122}

const _OpLowerName = "nopretserrorhaltrcsrwcsrmoveloadcimmjumpcallsysloadstoreloadbstorebaddsubaddcsubcxorandorshlshrasrifeqifneifltifgeifloifhs"

func (i Op) String() string {
	if i < 0 || i >= Op(len(_OpIndex)-1) {
		return fmt.Sprintf("Op(%d)", i)
	}
	return _OpName[_OpIndex[i]:_OpIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _OpNoOp() {
	var x [1]struct{}
	_ = x[Nop-(0)]
	_ = x[Rets-(1)]
	_ = x[Error-(2)]
	_ = x[Halt-(3)]
	_ = x[Rcsr-(4)]
	_ = x[Wcsr-(5)]
	_ = x[Move-(6)]
	_ = x[Loadc-(7)]
	_ = x[Imm-(8)]
	_ = x[Jump-(9)]
	_ = x[Call-(10)]
	_ = x[Sys-(11)]
	_ = x[Load-(12)]
	_ = x[Store-(13)]
	_ = x[Loadb-(14)]
	_ = x[Storeb-(15)]
	_ = x[Add-(16)]
	_ = x[Sub-(17)]
	_ = x[Addc-(18)]
	_ = x[Subc-(19)]
	_ = x[Xor-(20)]
	_ = x[And-(21)]
	_ = x[Or-(22)]
	_ = x[Shl-(23)]
	_ = x[Shr-(24)]
	_ = x[Asr-(25)]
	_ = x[IfEq-(26)]
	_ = x[IfNe-(27)]
	_ = x[IfLt-(28)]
	_ = x[IfGe-(29)]
	_ = x[IfLo-(30)]
	_ = x[IfHs-(31)]
}

var _OpValues = []Op{Nop, Rets, Error, Halt, Rcsr, Wcsr, Move, Loadc, Imm, Jump, Call, Sys, Load, Store, Loadb, Storeb, Add, Sub, Addc, Subc, Xor, And, Or, Shl, Shr, Asr, IfEq, IfNe, IfLt, IfGe, IfLo, IfHs}

var _OpNameToValueMap = map[string]Op{
	_OpName[0:3]:          Nop,
	_OpLowerName[0:3]:     Nop,
	_OpName[3:7]:          Rets,
	_OpLowerName[3:7]:     Rets,
	_OpName[7:12]:         Error,
	_OpLowerName[7:12]:    Error,
	_OpName[12:16]:        Halt,
	_OpLowerName[12:16]:   Halt,
	_OpName[16:20]:        Rcsr,
	_OpLowerName[16:20]:   Rcsr,
	_OpName[20:24]:        Wcsr,
	_OpLowerName[20:24]:   Wcsr,
	_OpName[24:28]:        Move,
	_OpLowerName[24:28]:   Move,
	_OpName[28:33]:        Loadc,
	_OpLowerName[28:33]:   Loadc,
	_OpName[33:36]:        Imm,
	_OpLowerName[33:36]:   Imm,
	_OpName[36:40]:        Jump,
	_OpLowerName[36:40]:   Jump,
	_OpName[40:44]:        Call,
	_OpLowerName[40:44]:   Call,
	_OpName[44:47]:        Sys,
	_OpLowerName[44:47]:   Sys,
	_OpName[47:51]:        Load,
	_OpLowerName[47:51]:   Load,
	_OpName[51:56]:        Store,
	_OpLowerName[51:56]:   Store,
	_OpName[56:61]:        Loadb,
	_OpLowerName[56:61]:   Loadb,
	_OpName[61:67]:        Storeb,
	_OpLowerName[61:67]:   Storeb,
	_OpName[67:70]:        Add,
	_OpLowerName[67:70]:   Add,
	_OpName[70:73]:        Sub,
	_OpLowerName[70:73]:   Sub,
	_OpName[73:77]:        Addc,
	_OpLowerName[73:77]:   Addc,
	_OpName[77:81]:        Subc,
	_OpLowerName[77:81]:   Subc,
	_OpName[81:84]:        Xor,
	_OpLowerName[81:84]:   Xor,
	_OpName[84:87]:        And,
	_OpLowerName[84:87]:   And,
	_OpName[87:89]:        Or,
	_OpLowerName[87:89]:   Or,
	_OpName[89:92]:        Shl,
	_OpLowerName[89:92]:   Shl,
	_OpName[92:95]:        Shr,
	_OpLowerName[92:95]:   Shr,
	_OpName[95:98]:        Asr,
	_OpLowerName[95:98]:   Asr,
	_OpName[98:102]:       IfEq,
	_OpLowerName[98:102]:  IfEq,
	_OpName[102:106]:      IfNe,
	_OpLowerName[102:106]: IfNe,
	_OpName[106:110]:      IfLt,
	_OpLowerName[106:110]: IfLt,
	_OpName[110:114]:      IfGe,
	_OpLowerName[110:114]: IfGe,
	_OpName[114:118]:      IfLo,
	_OpLowerName[114:118]: IfLo,
	_OpName[118:122]:      IfHs,
	_OpLowerName[118:122]: IfHs,
}

var _OpNames = []string{
	_OpName[0:3],
	_OpName[3:7],
	_OpName[7:12],
	_OpName[12:16],
	_OpName[16:20],
	_OpName[20:24],
	_OpName[24:28],
	_OpName[28:33],
	_OpName[33:36],
	_OpName[36:40],
	_OpName[40:44],
	_OpName[44:47],
	_OpName[47:51],
	_OpName[51:56],
	_OpName[56:61],
	_OpName[61:67],
	_OpName[67:70],
	_OpName[70:73],
	_OpName[73:77],
	_OpName[77:81],
	_OpName[81:84],
	_OpName[84:87],
	_OpName[87:89],
	_OpName[89:92],
	_OpName[92:95],
	_OpName[95:98],
	_OpName[98:102],
	_OpName[102:106],
	_OpName[106:110],
	_OpName[110:114],
	_OpName[114:118],
	_OpName[118:122],
}

// OpString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func OpString(s string) (Op, error) {
	if val, ok := _OpNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _OpNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Op values", s)
}

// OpValues returns all values of the enum
func OpValues() []Op {
	return _OpValues
}

// OpStrings returns a slice of all String values of the enum
func OpStrings() []string {
	strs := make([]string, len(_OpNames))
	copy(strs, _OpNames)
	return strs
}

// IsAOp returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Op) IsAOp() bool {
	for _, v := range _OpValues {
		if i == v {
			return true
		}
	}
	return false
}

const _FmtName = "rrextlsri6ri8i11"

var _FmtIndex = [...]uint8{0, 2, 5, 7, 10, 13, 16}

const _FmtLowerName = "rrextlsri6ri8i11"

func (i Fmt) String() string {
	if i < 0 || i >= Fmt(len(_FmtIndex)-1) {
		return fmt.Sprintf("Fmt(%d)", i)
	}
	return _FmtName[_FmtIndex[i]:_FmtIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _FmtNoOp() {
	var x [1]struct{}
	_ = x[FmtRR-(0)]
	_ = x[FmtExt-(1)]
	_ = x[FmtLS-(2)]
	_ = x[FmtRI6-(3)]
	_ = x[FmtRI8-(4)]
	_ = x[FmtI11-(5)]
}

var _FmtValues = []Fmt{FmtRR, FmtExt, FmtLS, FmtRI6, FmtRI8, FmtI11}

var _FmtNameToValueMap = map[string]Fmt{
	_FmtName[0:2]:        FmtRR,
	_FmtLowerName[0:2]:   FmtRR,
	_FmtName[2:5]:        FmtExt,
	_FmtLowerName[2:5]:   FmtExt,
	_FmtName[5:7]:        FmtLS,
	_FmtLowerName[5:7]:   FmtLS,
	_FmtName[7:10]:       FmtRI6,
	_FmtLowerName[7:10]:  FmtRI6,
	_FmtName[10:13]:      FmtRI8,
	_FmtLowerName[10:13]: FmtRI8,
	_FmtName[13:16]:      FmtI11,
	_FmtLowerName[13:16]: FmtI11,
}

var _FmtNames = []string{
	_FmtName[0:2],
	_FmtName[2:5],
	_FmtName[5:7],
	_FmtName[7:10],
	_FmtName[10:13],
	_FmtName[13:16],
}

// FmtString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func FmtString(s string) (Fmt, error) {
	if val, ok := _FmtNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _FmtNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Fmt values", s)
}

// FmtValues returns all values of the enum
func FmtValues() []Fmt {
	return _FmtValues
}

// FmtStrings returns a slice of all String values of the enum
func FmtStrings() []string {
	strs := make([]string, len(_FmtNames))
	copy(strs, _FmtNames)
	return strs
}

// IsAFmt returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Fmt) IsAFmt() bool {
	for _, v := range _FmtValues {
		if i == v {
			return true
		}
	}
	return false
}
