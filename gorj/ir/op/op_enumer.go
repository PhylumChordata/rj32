// Code generated by "enumer -type=Op -transform title-lower -json -text"; DO NOT EDIT.

package op

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _OpName = "invalidbuiltincallchangeInterfacechangeTypeconstconvertextractfieldfieldAddrfreeVarfuncglobalindexindexAddrlocallookupmakeInterfacemakeSlicenextnewpanicparameterphirangeslicesliceToArrayPointerstoretypeAssertaddsubmuldivremandorxorshiftLeftshiftRightandNotequalnotEquallesslessEqualgreatergreaterEqualnotnegateloadinvert"

var _OpIndex = [...]uint16{0, 7, 14, 18, 33, 43, 48, 55, 62, 67, 76, 83, 87, 93, 98, 107, 112, 118, 131, 140, 144, 147, 152, 161, 164, 169, 174, 193, 198, 208, 211, 214, 217, 220, 223, 226, 228, 231, 240, 250, 256, 261, 269, 273, 282, 289, 301, 304, 310, 314, 320}

const _OpLowerName = "invalidbuiltincallchangeinterfacechangetypeconstconvertextractfieldfieldaddrfreevarfuncglobalindexindexaddrlocallookupmakeinterfacemakeslicenextnewpanicparameterphirangesliceslicetoarraypointerstoretypeassertaddsubmuldivremandorxorshiftleftshiftrightandnotequalnotequallesslessequalgreatergreaterequalnotnegateloadinvert"

func (i Op) String() string {
	if i < 0 || i >= Op(len(_OpIndex)-1) {
		return fmt.Sprintf("Op(%d)", i)
	}
	return _OpName[_OpIndex[i]:_OpIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _OpNoOp() {
	var x [1]struct{}
	_ = x[Invalid-(0)]
	_ = x[Builtin-(1)]
	_ = x[Call-(2)]
	_ = x[ChangeInterface-(3)]
	_ = x[ChangeType-(4)]
	_ = x[Const-(5)]
	_ = x[Convert-(6)]
	_ = x[Extract-(7)]
	_ = x[Field-(8)]
	_ = x[FieldAddr-(9)]
	_ = x[FreeVar-(10)]
	_ = x[Func-(11)]
	_ = x[Global-(12)]
	_ = x[Index-(13)]
	_ = x[IndexAddr-(14)]
	_ = x[Local-(15)]
	_ = x[Lookup-(16)]
	_ = x[MakeInterface-(17)]
	_ = x[MakeSlice-(18)]
	_ = x[Next-(19)]
	_ = x[New-(20)]
	_ = x[Panic-(21)]
	_ = x[Parameter-(22)]
	_ = x[Phi-(23)]
	_ = x[Range-(24)]
	_ = x[Slice-(25)]
	_ = x[SliceToArrayPointer-(26)]
	_ = x[Store-(27)]
	_ = x[TypeAssert-(28)]
	_ = x[Add-(29)]
	_ = x[Sub-(30)]
	_ = x[Mul-(31)]
	_ = x[Div-(32)]
	_ = x[Rem-(33)]
	_ = x[And-(34)]
	_ = x[Or-(35)]
	_ = x[Xor-(36)]
	_ = x[ShiftLeft-(37)]
	_ = x[ShiftRight-(38)]
	_ = x[AndNot-(39)]
	_ = x[Equal-(40)]
	_ = x[NotEqual-(41)]
	_ = x[Less-(42)]
	_ = x[LessEqual-(43)]
	_ = x[Greater-(44)]
	_ = x[GreaterEqual-(45)]
	_ = x[Not-(46)]
	_ = x[Negate-(47)]
	_ = x[Load-(48)]
	_ = x[Invert-(49)]
}

var _OpValues = []Op{Invalid, Builtin, Call, ChangeInterface, ChangeType, Const, Convert, Extract, Field, FieldAddr, FreeVar, Func, Global, Index, IndexAddr, Local, Lookup, MakeInterface, MakeSlice, Next, New, Panic, Parameter, Phi, Range, Slice, SliceToArrayPointer, Store, TypeAssert, Add, Sub, Mul, Div, Rem, And, Or, Xor, ShiftLeft, ShiftRight, AndNot, Equal, NotEqual, Less, LessEqual, Greater, GreaterEqual, Not, Negate, Load, Invert}

var _OpNameToValueMap = map[string]Op{
	_OpName[0:7]:          Invalid,
	_OpLowerName[0:7]:     Invalid,
	_OpName[7:14]:         Builtin,
	_OpLowerName[7:14]:    Builtin,
	_OpName[14:18]:        Call,
	_OpLowerName[14:18]:   Call,
	_OpName[18:33]:        ChangeInterface,
	_OpLowerName[18:33]:   ChangeInterface,
	_OpName[33:43]:        ChangeType,
	_OpLowerName[33:43]:   ChangeType,
	_OpName[43:48]:        Const,
	_OpLowerName[43:48]:   Const,
	_OpName[48:55]:        Convert,
	_OpLowerName[48:55]:   Convert,
	_OpName[55:62]:        Extract,
	_OpLowerName[55:62]:   Extract,
	_OpName[62:67]:        Field,
	_OpLowerName[62:67]:   Field,
	_OpName[67:76]:        FieldAddr,
	_OpLowerName[67:76]:   FieldAddr,
	_OpName[76:83]:        FreeVar,
	_OpLowerName[76:83]:   FreeVar,
	_OpName[83:87]:        Func,
	_OpLowerName[83:87]:   Func,
	_OpName[87:93]:        Global,
	_OpLowerName[87:93]:   Global,
	_OpName[93:98]:        Index,
	_OpLowerName[93:98]:   Index,
	_OpName[98:107]:       IndexAddr,
	_OpLowerName[98:107]:  IndexAddr,
	_OpName[107:112]:      Local,
	_OpLowerName[107:112]: Local,
	_OpName[112:118]:      Lookup,
	_OpLowerName[112:118]: Lookup,
	_OpName[118:131]:      MakeInterface,
	_OpLowerName[118:131]: MakeInterface,
	_OpName[131:140]:      MakeSlice,
	_OpLowerName[131:140]: MakeSlice,
	_OpName[140:144]:      Next,
	_OpLowerName[140:144]: Next,
	_OpName[144:147]:      New,
	_OpLowerName[144:147]: New,
	_OpName[147:152]:      Panic,
	_OpLowerName[147:152]: Panic,
	_OpName[152:161]:      Parameter,
	_OpLowerName[152:161]: Parameter,
	_OpName[161:164]:      Phi,
	_OpLowerName[161:164]: Phi,
	_OpName[164:169]:      Range,
	_OpLowerName[164:169]: Range,
	_OpName[169:174]:      Slice,
	_OpLowerName[169:174]: Slice,
	_OpName[174:193]:      SliceToArrayPointer,
	_OpLowerName[174:193]: SliceToArrayPointer,
	_OpName[193:198]:      Store,
	_OpLowerName[193:198]: Store,
	_OpName[198:208]:      TypeAssert,
	_OpLowerName[198:208]: TypeAssert,
	_OpName[208:211]:      Add,
	_OpLowerName[208:211]: Add,
	_OpName[211:214]:      Sub,
	_OpLowerName[211:214]: Sub,
	_OpName[214:217]:      Mul,
	_OpLowerName[214:217]: Mul,
	_OpName[217:220]:      Div,
	_OpLowerName[217:220]: Div,
	_OpName[220:223]:      Rem,
	_OpLowerName[220:223]: Rem,
	_OpName[223:226]:      And,
	_OpLowerName[223:226]: And,
	_OpName[226:228]:      Or,
	_OpLowerName[226:228]: Or,
	_OpName[228:231]:      Xor,
	_OpLowerName[228:231]: Xor,
	_OpName[231:240]:      ShiftLeft,
	_OpLowerName[231:240]: ShiftLeft,
	_OpName[240:250]:      ShiftRight,
	_OpLowerName[240:250]: ShiftRight,
	_OpName[250:256]:      AndNot,
	_OpLowerName[250:256]: AndNot,
	_OpName[256:261]:      Equal,
	_OpLowerName[256:261]: Equal,
	_OpName[261:269]:      NotEqual,
	_OpLowerName[261:269]: NotEqual,
	_OpName[269:273]:      Less,
	_OpLowerName[269:273]: Less,
	_OpName[273:282]:      LessEqual,
	_OpLowerName[273:282]: LessEqual,
	_OpName[282:289]:      Greater,
	_OpLowerName[282:289]: Greater,
	_OpName[289:301]:      GreaterEqual,
	_OpLowerName[289:301]: GreaterEqual,
	_OpName[301:304]:      Not,
	_OpLowerName[301:304]: Not,
	_OpName[304:310]:      Negate,
	_OpLowerName[304:310]: Negate,
	_OpName[310:314]:      Load,
	_OpLowerName[310:314]: Load,
	_OpName[314:320]:      Invert,
	_OpLowerName[314:320]: Invert,
}

var _OpNames = []string{
	_OpName[0:7],
	_OpName[7:14],
	_OpName[14:18],
	_OpName[18:33],
	_OpName[33:43],
	_OpName[43:48],
	_OpName[48:55],
	_OpName[55:62],
	_OpName[62:67],
	_OpName[67:76],
	_OpName[76:83],
	_OpName[83:87],
	_OpName[87:93],
	_OpName[93:98],
	_OpName[98:107],
	_OpName[107:112],
	_OpName[112:118],
	_OpName[118:131],
	_OpName[131:140],
	_OpName[140:144],
	_OpName[144:147],
	_OpName[147:152],
	_OpName[152:161],
	_OpName[161:164],
	_OpName[164:169],
	_OpName[169:174],
	_OpName[174:193],
	_OpName[193:198],
	_OpName[198:208],
	_OpName[208:211],
	_OpName[211:214],
	_OpName[214:217],
	_OpName[217:220],
	_OpName[220:223],
	_OpName[223:226],
	_OpName[226:228],
	_OpName[228:231],
	_OpName[231:240],
	_OpName[240:250],
	_OpName[250:256],
	_OpName[256:261],
	_OpName[261:269],
	_OpName[269:273],
	_OpName[273:282],
	_OpName[282:289],
	_OpName[289:301],
	_OpName[301:304],
	_OpName[304:310],
	_OpName[310:314],
	_OpName[314:320],
}

// OpString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func OpString(s string) (Op, error) {
	if val, ok := _OpNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _OpNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Op values", s)
}

// OpValues returns all values of the enum
func OpValues() []Op {
	return _OpValues
}

// OpStrings returns a slice of all String values of the enum
func OpStrings() []string {
	strs := make([]string, len(_OpNames))
	copy(strs, _OpNames)
	return strs
}

// IsAOp returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Op) IsAOp() bool {
	for _, v := range _OpValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Op
func (i Op) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Op
func (i *Op) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Op should be a string, got %s", data)
	}

	var err error
	*i, err = OpString(s)
	return err
}

// MarshalText implements the encoding.TextMarshaler interface for Op
func (i Op) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Op
func (i *Op) UnmarshalText(text []byte) error {
	var err error
	*i, err = OpString(string(text))
	return err
}
