// Code generated by "enumer -type=Op -transform title-lower"; DO NOT EDIT.

package op

import (
	"fmt"
	"strings"
)

const _OpName = "invalidbuiltincallcallBuiltinchangeInterfacechangeTypeconstconvertcopyextractfieldfieldAddrfreeVarfuncglobalindexindexAddrlocallookupmakeInterfacemakeSlicenextnewparameterphiphiCopyrangeregslicesliceToArrayPointerstoreswapInswapOuttypeAssertaddsubmuldivremandorxorshiftLeftshiftRightandNotequalnotEquallesslessEqualgreatergreaterEqualnotnegateloadinvertnumOps"

var _OpIndex = [...]uint16{0, 7, 14, 18, 29, 44, 54, 59, 66, 70, 77, 82, 91, 98, 102, 108, 113, 122, 127, 133, 146, 155, 159, 162, 171, 174, 181, 186, 189, 194, 213, 218, 224, 231, 241, 244, 247, 250, 253, 256, 259, 261, 264, 273, 283, 289, 294, 302, 306, 315, 322, 334, 337, 343, 347, 353, 359}

const _OpLowerName = "invalidbuiltincallcallbuiltinchangeinterfacechangetypeconstconvertcopyextractfieldfieldaddrfreevarfuncglobalindexindexaddrlocallookupmakeinterfacemakeslicenextnewparameterphiphicopyrangeregsliceslicetoarraypointerstoreswapinswapouttypeassertaddsubmuldivremandorxorshiftleftshiftrightandnotequalnotequallesslessequalgreatergreaterequalnotnegateloadinvertnumops"

func (i Op) String() string {
	if i < 0 || i >= Op(len(_OpIndex)-1) {
		return fmt.Sprintf("Op(%d)", i)
	}
	return _OpName[_OpIndex[i]:_OpIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _OpNoOp() {
	var x [1]struct{}
	_ = x[Invalid-(0)]
	_ = x[Builtin-(1)]
	_ = x[Call-(2)]
	_ = x[CallBuiltin-(3)]
	_ = x[ChangeInterface-(4)]
	_ = x[ChangeType-(5)]
	_ = x[Const-(6)]
	_ = x[Convert-(7)]
	_ = x[Copy-(8)]
	_ = x[Extract-(9)]
	_ = x[Field-(10)]
	_ = x[FieldAddr-(11)]
	_ = x[FreeVar-(12)]
	_ = x[Func-(13)]
	_ = x[Global-(14)]
	_ = x[Index-(15)]
	_ = x[IndexAddr-(16)]
	_ = x[Local-(17)]
	_ = x[Lookup-(18)]
	_ = x[MakeInterface-(19)]
	_ = x[MakeSlice-(20)]
	_ = x[Next-(21)]
	_ = x[New-(22)]
	_ = x[Parameter-(23)]
	_ = x[Phi-(24)]
	_ = x[PhiCopy-(25)]
	_ = x[Range-(26)]
	_ = x[Reg-(27)]
	_ = x[Slice-(28)]
	_ = x[SliceToArrayPointer-(29)]
	_ = x[Store-(30)]
	_ = x[SwapIn-(31)]
	_ = x[SwapOut-(32)]
	_ = x[TypeAssert-(33)]
	_ = x[Add-(34)]
	_ = x[Sub-(35)]
	_ = x[Mul-(36)]
	_ = x[Div-(37)]
	_ = x[Rem-(38)]
	_ = x[And-(39)]
	_ = x[Or-(40)]
	_ = x[Xor-(41)]
	_ = x[ShiftLeft-(42)]
	_ = x[ShiftRight-(43)]
	_ = x[AndNot-(44)]
	_ = x[Equal-(45)]
	_ = x[NotEqual-(46)]
	_ = x[Less-(47)]
	_ = x[LessEqual-(48)]
	_ = x[Greater-(49)]
	_ = x[GreaterEqual-(50)]
	_ = x[Not-(51)]
	_ = x[Negate-(52)]
	_ = x[Load-(53)]
	_ = x[Invert-(54)]
	_ = x[NumOps-(55)]
}

var _OpValues = []Op{Invalid, Builtin, Call, CallBuiltin, ChangeInterface, ChangeType, Const, Convert, Copy, Extract, Field, FieldAddr, FreeVar, Func, Global, Index, IndexAddr, Local, Lookup, MakeInterface, MakeSlice, Next, New, Parameter, Phi, PhiCopy, Range, Reg, Slice, SliceToArrayPointer, Store, SwapIn, SwapOut, TypeAssert, Add, Sub, Mul, Div, Rem, And, Or, Xor, ShiftLeft, ShiftRight, AndNot, Equal, NotEqual, Less, LessEqual, Greater, GreaterEqual, Not, Negate, Load, Invert, NumOps}

var _OpNameToValueMap = map[string]Op{
	_OpName[0:7]:          Invalid,
	_OpLowerName[0:7]:     Invalid,
	_OpName[7:14]:         Builtin,
	_OpLowerName[7:14]:    Builtin,
	_OpName[14:18]:        Call,
	_OpLowerName[14:18]:   Call,
	_OpName[18:29]:        CallBuiltin,
	_OpLowerName[18:29]:   CallBuiltin,
	_OpName[29:44]:        ChangeInterface,
	_OpLowerName[29:44]:   ChangeInterface,
	_OpName[44:54]:        ChangeType,
	_OpLowerName[44:54]:   ChangeType,
	_OpName[54:59]:        Const,
	_OpLowerName[54:59]:   Const,
	_OpName[59:66]:        Convert,
	_OpLowerName[59:66]:   Convert,
	_OpName[66:70]:        Copy,
	_OpLowerName[66:70]:   Copy,
	_OpName[70:77]:        Extract,
	_OpLowerName[70:77]:   Extract,
	_OpName[77:82]:        Field,
	_OpLowerName[77:82]:   Field,
	_OpName[82:91]:        FieldAddr,
	_OpLowerName[82:91]:   FieldAddr,
	_OpName[91:98]:        FreeVar,
	_OpLowerName[91:98]:   FreeVar,
	_OpName[98:102]:       Func,
	_OpLowerName[98:102]:  Func,
	_OpName[102:108]:      Global,
	_OpLowerName[102:108]: Global,
	_OpName[108:113]:      Index,
	_OpLowerName[108:113]: Index,
	_OpName[113:122]:      IndexAddr,
	_OpLowerName[113:122]: IndexAddr,
	_OpName[122:127]:      Local,
	_OpLowerName[122:127]: Local,
	_OpName[127:133]:      Lookup,
	_OpLowerName[127:133]: Lookup,
	_OpName[133:146]:      MakeInterface,
	_OpLowerName[133:146]: MakeInterface,
	_OpName[146:155]:      MakeSlice,
	_OpLowerName[146:155]: MakeSlice,
	_OpName[155:159]:      Next,
	_OpLowerName[155:159]: Next,
	_OpName[159:162]:      New,
	_OpLowerName[159:162]: New,
	_OpName[162:171]:      Parameter,
	_OpLowerName[162:171]: Parameter,
	_OpName[171:174]:      Phi,
	_OpLowerName[171:174]: Phi,
	_OpName[174:181]:      PhiCopy,
	_OpLowerName[174:181]: PhiCopy,
	_OpName[181:186]:      Range,
	_OpLowerName[181:186]: Range,
	_OpName[186:189]:      Reg,
	_OpLowerName[186:189]: Reg,
	_OpName[189:194]:      Slice,
	_OpLowerName[189:194]: Slice,
	_OpName[194:213]:      SliceToArrayPointer,
	_OpLowerName[194:213]: SliceToArrayPointer,
	_OpName[213:218]:      Store,
	_OpLowerName[213:218]: Store,
	_OpName[218:224]:      SwapIn,
	_OpLowerName[218:224]: SwapIn,
	_OpName[224:231]:      SwapOut,
	_OpLowerName[224:231]: SwapOut,
	_OpName[231:241]:      TypeAssert,
	_OpLowerName[231:241]: TypeAssert,
	_OpName[241:244]:      Add,
	_OpLowerName[241:244]: Add,
	_OpName[244:247]:      Sub,
	_OpLowerName[244:247]: Sub,
	_OpName[247:250]:      Mul,
	_OpLowerName[247:250]: Mul,
	_OpName[250:253]:      Div,
	_OpLowerName[250:253]: Div,
	_OpName[253:256]:      Rem,
	_OpLowerName[253:256]: Rem,
	_OpName[256:259]:      And,
	_OpLowerName[256:259]: And,
	_OpName[259:261]:      Or,
	_OpLowerName[259:261]: Or,
	_OpName[261:264]:      Xor,
	_OpLowerName[261:264]: Xor,
	_OpName[264:273]:      ShiftLeft,
	_OpLowerName[264:273]: ShiftLeft,
	_OpName[273:283]:      ShiftRight,
	_OpLowerName[273:283]: ShiftRight,
	_OpName[283:289]:      AndNot,
	_OpLowerName[283:289]: AndNot,
	_OpName[289:294]:      Equal,
	_OpLowerName[289:294]: Equal,
	_OpName[294:302]:      NotEqual,
	_OpLowerName[294:302]: NotEqual,
	_OpName[302:306]:      Less,
	_OpLowerName[302:306]: Less,
	_OpName[306:315]:      LessEqual,
	_OpLowerName[306:315]: LessEqual,
	_OpName[315:322]:      Greater,
	_OpLowerName[315:322]: Greater,
	_OpName[322:334]:      GreaterEqual,
	_OpLowerName[322:334]: GreaterEqual,
	_OpName[334:337]:      Not,
	_OpLowerName[334:337]: Not,
	_OpName[337:343]:      Negate,
	_OpLowerName[337:343]: Negate,
	_OpName[343:347]:      Load,
	_OpLowerName[343:347]: Load,
	_OpName[347:353]:      Invert,
	_OpLowerName[347:353]: Invert,
	_OpName[353:359]:      NumOps,
	_OpLowerName[353:359]: NumOps,
}

var _OpNames = []string{
	_OpName[0:7],
	_OpName[7:14],
	_OpName[14:18],
	_OpName[18:29],
	_OpName[29:44],
	_OpName[44:54],
	_OpName[54:59],
	_OpName[59:66],
	_OpName[66:70],
	_OpName[70:77],
	_OpName[77:82],
	_OpName[82:91],
	_OpName[91:98],
	_OpName[98:102],
	_OpName[102:108],
	_OpName[108:113],
	_OpName[113:122],
	_OpName[122:127],
	_OpName[127:133],
	_OpName[133:146],
	_OpName[146:155],
	_OpName[155:159],
	_OpName[159:162],
	_OpName[162:171],
	_OpName[171:174],
	_OpName[174:181],
	_OpName[181:186],
	_OpName[186:189],
	_OpName[189:194],
	_OpName[194:213],
	_OpName[213:218],
	_OpName[218:224],
	_OpName[224:231],
	_OpName[231:241],
	_OpName[241:244],
	_OpName[244:247],
	_OpName[247:250],
	_OpName[250:253],
	_OpName[253:256],
	_OpName[256:259],
	_OpName[259:261],
	_OpName[261:264],
	_OpName[264:273],
	_OpName[273:283],
	_OpName[283:289],
	_OpName[289:294],
	_OpName[294:302],
	_OpName[302:306],
	_OpName[306:315],
	_OpName[315:322],
	_OpName[322:334],
	_OpName[334:337],
	_OpName[337:343],
	_OpName[343:347],
	_OpName[347:353],
	_OpName[353:359],
}

// OpString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func OpString(s string) (Op, error) {
	if val, ok := _OpNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _OpNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Op values", s)
}

// OpValues returns all values of the enum
func OpValues() []Op {
	return _OpValues
}

// OpStrings returns a slice of all String values of the enum
func OpStrings() []string {
	strs := make([]string, len(_OpNames))
	copy(strs, _OpNames)
	return strs
}

// IsAOp returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Op) IsAOp() bool {
	for _, v := range _OpValues {
		if i == v {
			return true
		}
	}
	return false
}
