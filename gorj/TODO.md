# Things left to do

- [x] build register allocation verification
- [x] fix load store bugs
- [x] properly handle parameters with a copy
- [x] switch allocator to use uses data structure for liveness tracking
  - [x] in uses liveness calculator, special case phis
    - [x] phis should act like copies in source block
    - [x] if the value does not live
      - [x] it should not be in live out
      - [x] it should be in block kill list
- [x] top to bottom register allocation verification?
- [x] it seems like back-links (loops) are not handled properly in the register allocator yet
- [x] fix value overwrites in the register allocator
- [x] get ssa dump html to have final assembly output
- [x] emit ssa dump html on command line arg
- [x] get a test suite working
  - [x] ability to write .asm files
  - [x] can invoke customasm to produce .hex files
  - [x] can invoke emulator to run the .hex files
  - [x] set up a test runner
  - [x] start writing some simple test programs inspired by c-test-suite
- [x] storing a const needs a register `store  [gp, main__init_guard], 1`
- [x] implement function parameters
  - [x] add parameters to function entry
  - [x] handle register ABI for parameters
- [x] working register allocator
  - [x] implement parallel phi moves
  - [x] convert boolean checks into proper block types
  - [x] try to assign moves the same register so it will be eliminated
  - [x] use a better live value scanner
    - [x] handles loops properly
      - [x] includes branches and other control forks inside the loop
      - [x] fixed point iterative analysis (more accurate)
    - [x] can emit a .dot file for debugging
    - [x] phis and phi copies handled correctly
    - [x] makes sure all loop extended vars have liveThroughCalls set properly
    - [x] better debugging of liveness with graphviz
  - [x] reorder PhiCopies so they don't clobber regs
    - [x] may need to swap sometimes
- [x] hide debugging spam with flags
- [x] if a function has multiple returns
  - [x] create a common exit block
  - [x] set successors for each return block to it
  - [x] create a phi in the return block for each returned value
  - [x] change return to jump, remove controls
- [x] handle stack ABI for parameters
  - [x] loading on callee side
  - [x] storing on caller side

## milestone get: min useful compiler

- now has ability to compile simple programs that use only word data
  - global structs and arrays supported
  - allocator does not support spills
    - crashes if it needs more registers than available

- [x] implement multiple function return values
  - [x] copies return values to registers a0-a2 in function
  - [x] copies extracted values from registers a0-a2 at call site
  - [x] test case built
- [x] storing comparisons in a bool
- [x] fix bug where return values happen after register restores
- [ ] fix bugs with self referential phis
- [x] add go source to ssa.html dump
- [x] add original tools/go/ssa source to ssa.html dump
- [x] better assembly IR / output
  - [x] design a lowest level IR for assembly
  - [x] add a module for rj32 specific assembly generation
  - [x] generate the assembly IR for rj32
  - [x] add a pretty html dump to ssa.html
  - [x] add ability to convert assembly IR into text
  - [x] convert codegen to only produce the IR
- [ ] better register allocation
  - [x] remove register "guessing" -- don't think that's necessary
  - [x] improved register colouring debugging info
  - [ ] add function return values to register verifier
  - [ ] stronger out-of-ssa handling
    - [ ] proper CSSA back out
      - [ ] additional parallel moves after the phi
      - [ ] remove assumption that PhiCopies are only at the end of a block
      - [ ] handle transition from Phi to PhiCopy block properly
- [.] start a standard library
  - [ ] implement some `runtime` functions
    - [x] string iterator next function
  - [x] loaded package replacement
    - [x] build an alternate goroot with replacement packages
    - [x] replace `runtime` package
    - [x] force `runtime` to be loaded
  - [ ] only parse functions actually used
    - [ ] make sure uses of runtime ops are loaded
  - [ ] add runtime library support for builtin ops
    - [ ] implement mul in go
    - [ ] implement div in go
    - [ ] implement rem in go
    - [ ] implement double and quad word ops
      - [ ] add/sub should use addc/subc
      - [ ] shifts should do a function call
      - [ ] either multi-def support or register pair support
- [ ] proper error logging with a reference to the original code location
- [ ] Documentation especially around the IR package
- [ ] string support
  - [x] support len() builtin
    - [x] parses
    - [x] implemented as a load of the second value in the tuple
  - [x] iteration support
    - [x] range statements for strings
      - [x] parsed
      - [x] implemented as an iterator
    - [x] string iterator next op
      - [x] parsed
      - [x] calls an iterator function
  - [x] indexing strings
    - [x] address part of tuple loads
    - [x] offset calculated and loaded
    - [x] strings are UTF-16
    - [ ] multi-word UTF-16 character support
    - [ ] 32-bit runes
  - [x] string len() support
  - [ ] string to slice of bytes conversion
  - [ ] slice of bytes to string conversion
  - [ ] string to slice of runes
  - [ ] slice of runes to string
  - [ ] utf8 expansion in range operator
  - [ ] string less comparison
  - [ ] string equal comparison
  - [ ] string concatenation
  - [ ] string slicing / substring


- [ ] Add support for a second CPU to make adding more easier
  - [ ] Artentus' A32
    - [x] Add arch abstraction with an rj32 implementation
    - [x] Abstract away registers and their use classes
      - [x] Add register abstraction with config from rj32 arch
      - [x] Allow 32 registers
    - [x] Support a different ABI
    - [x] Allow sizes to be parameterized by arch
      - [x] Add sizes to rj32 arch
      - [ ] Support 32-bit, 16-bit and 8-bit values
      - [x] Support byte addressing
    - [x] Fix hard-coded number of arg regs
      - [x] Fix arg spill code in elaborating calls
      - [x] Fix arg consume code in prologue
      - [x] Fix other references to reg.ArgRegs
    - [x] Support three operand instructions configured by arch
      - [x] Ensure ClobbersArg is false on 3-op arches
      - [x] Legalize should not insert copies on 3-op arches
      - [x] Instructions for A32 emit 3 operands
    - [x] Add support for different cpudefs
    - [x] Add support for different emulators
    - [ ] Add stdlib support for different arches
      - [ ] Move IO into the standard Library
      - [ ] Figure out how to utilize the IN/OUT instructions of A32
      - [ ] Fix panic to write to standard out / IO
    - [ ] Round robin reg choosing
    - [x] Make stack slots word-size aware
    - [ ] Make stack slots align aware

- [ ] Rework xform system
  - [ ] Have a better way to track which rules have run to trigger what code to be generated
    - [ ] Instrument SSA dump with code location that generated the code
    - [ ] A way to allow debugging of rule matching conditions inputs outputs and generated code in the ssa.html
  - [x] Transformation tagging with the architecture or other things using configuration functions
    - [x] Ability to configure the tags for each transformation function close to where the function is defined
      - [ ] A way to automatically document rules their inputs and outputs their purpose and automatically assign an ID to them and have a way to list documentation about them at the command line
    - [x] An architecture can have many tags that are associated with it that can describe which rules are active
    - [ ] A way to denote which rules/tags were active in each pass for a given architecture in the ssa.html
    - [ ] Split larger transformations apart so that they are more fine-grained and thus easier to tag for specific architectures
    - [ ] Have a way to easily run a transformation at the function or block level
  - [ ] Have a way to denote how far back in the instruction list to backtrack if a change is made
    - [ ] Make that back tracking automatic so the rule doesn't have to specify it
  - [ ] Have a way to specify the dependencies or rules that have to execute first or prerequisites
    - [ ] Maintain a candidate rule list and as that rule satisfies prerequisites of other rules add those to the candidate list
    - [ ] This will allow it to automatically figure out the order to apply rules and figure out the phases accordingly
    - [ ] A way to add rules based on architecture sizes information
  - [ ] Instead of the rule having a bunch of if conditions to denote that it doesn't work have a way to specify what conditions need to be matching before the rule is ever considered
    - [ ] Have a way to denote that a rule no longer applies and can be removed from the candidate list
      - [ ] Automatically track new instructions and new code generated to see if previously rules that have been removed from the candidate list may now apply again
    - [ ] Have a way to re-trigger a transformation if any changes are made but only if another transformation has it as a prerequisite and before that one is redone
  - [ ] Register allocation as just a regular transformation
  - [ ] Think about how to add types to the xform engine
    - [ ] Type verifier that will check to make sure that the return types of ops are correct
    - [ ] A way to add types to architecture op translation

- [ ] better copy elimination (coalescing)
  - [ ] add register preference scanning
- [ ] track what registers are actually used by a call site
  - [ ] reduce the register restrictions (with flag to disable)
- [ ] stack / spill support
- [ ] create spills for temp vars still live at a call
  - [ ] reload after
- [ ] build way to count register pressure
  - [ ] add spill support to lower register pressure
- [ ] implement graph coloring in register allocator
  - [ ] implement adjacency lists for the graph
    - [ ] nodes can be marked as move related
    - [ ] nodes can be merged so multiple values are in one node
    - [ ] nodes can be removed one-by-one
    - [ ] fast finding of the nodes with least degree
  - [ ] use iterated register coalescing algo
- [ ] expand various ops into calls to functions implementing them
- [ ] stack allocation
  - [ ] slices
- [ ] heap allocation
  - [ ] free somehow?
- [ ] slice support
- [ ] closures
- [ ] Add make ready to prepare PRs or whatever
- [ ] Far pointer and code page banking
- [ ] Add notion of extended blocks as groups of blocks without back edges

## Optimizations

- [ ] fix allocator choosing wrong variable and doing extra copies
- [ ] copy propagation
  - given use of X:
    - are all reaching definitions of X
      - copies from the same variable, ie X = copy Y
    - where Y is not redefined since that variable?
    - if so, substitute use of X with use of Y instead
- [ ] move instruction defs closer to first uses to minimize reg pressure
- [ ] constant folding
- [ ] common subexpression elimination
  - [ ] start at entry
  - [ ] for each block copy value map from predecessors
    - [ ] ignore preds that have not been visited yet
  - [ ] for commutative operations, order in ascending order
  - [ ] hash op + arg1 + arg2
  - [ ] if already exists in value map, replace with value from that map
    - [ ] update map with new latest value
    - [ ] hash and lookup new resulting expression
  - [ ] if doesn't exist, add to map with the result value
- [ ] dead code elimination
- [ ] find all loops
  - [ ] loop invariant code motion
    - [ ] if for def X, no args refer to a phi node or def inside the loop
      - [ ] move X out of the loop into the pre-header
  - [ ] find loop induction variables?
    - [ ] do strength reduction on uses of induction variable?
      - like array indexing for example
  - [ ] support for inline assembly / extern assembly
    - [ ] get mul, div and rem converted to assembly
