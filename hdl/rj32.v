/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module clockctrl (
  input clock,
  input step,
  input slow,
  input fast,
  input faster,
  output stall
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire [22:0] s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i0 (
    .Set( 1'b0 ),
    .D( s3 ),
    .C( clock ),
    .Clr( step ),
    .Q( s4 )
  );
  assign s3 = (s4 | slow);
  DIG_Counter_Nbit #(
    .Bits(23)
  )
  DIG_Counter_Nbit_i1 (
    .en( s4 ),
    .C( clock ),
    .clr( step ),
    .out( s6 )
  );
  assign s5 = (s7 | step);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( s10 ),
    .C( clock ),
    .Clr( step ),
    .Q( s11 )
  );
  assign s10 = (fast | s11);
  Mux_2x1 Mux_2x1_i3 (
    .sel( faster ),
    .in_0( s8 ),
    .in_1( s9 ),
    .out( s7 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i4 (
    .Set( s5 ),
    .D( 1'b0 ),
    .C( clock ),
    .Clr( 1'b0 ),
    .Q( s1 )
  );
  assign s8 = s6[22];
  assign s9 = s6[2];
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i5 (
    .D( s1 ),
    .C( clock ),
    .\~Q ( s2 )
  );
  assign s0 = ((s1 & s2) | s11);
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i6 (
    .D( s0 ),
    .C( clock ),
    .\~Q ( stall )
  );
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module fetch (
  input [15:0] instr_i,
  input clock,
  input fetch,
  input jump,
  input [15:0] value,
  input en,
  output [15:0] instr_o,
  output [7:0] pc
);
  wire [7:0] s0;
  wire s1;
  wire s2;
  wire [15:0] s3;
  assign s2 = (jump & en);
  assign s0 = value[7:0];
  assign s1 = (fetch & s2);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i0 (
    .sel( s2 ),
    .in_0( instr_i ),
    .in_1( 16'b0 ),
    .out( s3 )
  );
  // PC
  DIG_CounterPreset #(
    .Bits(8),
    .maxValue(0)
  )
  DIG_CounterPreset_i1 (
    .en( fetch ),
    .C( clock ),
    .dir( 1'b0 ),
    .in( s0 ),
    .ld( s1 ),
    .clr( 1'b0 ),
    .out( pc )
  );
  // IR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( s3 ),
    .C( clock ),
    .en( fetch ),
    .Q( instr_o )
  );
endmodule
module DIG_ROM_32X16_Microcode (
    input [4:0] A,
    input sel,
    output reg [15:0] D
);
    reg [15:0] my_rom [0:31];

    always @ (*) begin
        if (~sel)
            D = 16'hz;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 16'h0;
        my_rom[1] = 16'h0;
        my_rom[2] = 16'h2;
        my_rom[3] = 16'h1;
        my_rom[4] = 16'h0;
        my_rom[5] = 16'h0;
        my_rom[6] = 16'h0;
        my_rom[7] = 16'h0;
        my_rom[8] = 16'h0;
        my_rom[9] = 16'h0;
        my_rom[10] = 16'h0;
        my_rom[11] = 16'h0;
        my_rom[12] = 16'h0;
        my_rom[13] = 16'h0;
        my_rom[14] = 16'h0;
        my_rom[15] = 16'h0;
        my_rom[16] = 16'h8;
        my_rom[17] = 16'h28;
        my_rom[18] = 16'h0;
        my_rom[19] = 16'h0;
        my_rom[20] = 16'h0;
        my_rom[21] = 16'h0;
        my_rom[22] = 16'h18;
        my_rom[23] = 16'h0;
        my_rom[24] = 16'h20;
        my_rom[25] = 16'h0;
        my_rom[26] = 16'h0;
        my_rom[27] = 16'h0;
        my_rom[28] = 16'h4;
        my_rom[29] = 16'h0;
        my_rom[30] = 16'h48;
        my_rom[31] = 16'hc8;
    end
endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module control (
  input [4:0] op,
  input stall,
  input clock,
  input skip_n,
  output [2:0] aluop,
  output skip,
  output halt,
  output error,
  output en_write,
  output mem,
  output store,
  output en_fetch,
  output jump
);
  wire skip_temp;
  wire en_write_temp;
  wire en_fetch_temp;
  wire [15:0] s0;
  assign en_fetch_temp = ~ stall;
  // Microcode
  DIG_ROM_32X16_Microcode DIG_ROM_32X16_Microcode_i0 (
    .A( op ),
    .sel( 1'b1 ),
    .D( s0 )
  );
  // skip
  DIG_Register DIG_Register_i1 (
    .D( skip_n ),
    .C( clock ),
    .en( en_fetch_temp ),
    .Q( skip_temp )
  );
  assign jump = s0[2];
  assign aluop = s0[5:3];
  assign mem = s0[6];
  assign store = s0[7];
  assign en_write_temp = (~ skip_temp & en_fetch_temp);
  assign halt = (en_write_temp & s0[0]);
  assign error = (s0[1] & en_write_temp);
  assign skip = skip_temp;
  assign en_write = en_write_temp;
  assign en_fetch = en_fetch_temp;
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module memaccess (
  input [15:0] result,
  input [15:0] rdval,
  input mem,
  input memop,
  input [15:0] D,
  input en,
  output [15:0] wrval,
  output [13:0] A,
  output str,
  output [15:0] D_in
);
  wire [1:0] s0;
  assign s0[0] = memop;
  assign s0[1] = mem;
  assign str = (memop & mem & en);
  assign A = result[13:0];
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i0 (
    .sel( s0 ),
    .in_0( result ),
    .in_1( result ),
    .in_2( D ),
    .in_3( rdval ),
    .out( wrval )
  );
  assign D_in = rdval;
endmodule

module Decoder3 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    input [2:0] sel
);
    assign out_0 = (sel == 3'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 3'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 3'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 3'h3)? 1'b1 : 1'b0;
    assign out_4 = (sel == 3'h4)? 1'b1 : 1'b0;
    assign out_5 = (sel == 3'h5)? 1'b1 : 1'b0;
    assign out_6 = (sel == 3'h6)? 1'b1 : 1'b0;
    assign out_7 = (sel == 3'h7)? 1'b1 : 1'b0;
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module instdecoder (
  input [2:0] fmt,
  input [4:0] op0,
  output [4:0] op,
  output rd_valid,
  output rs_valid,
  output imm_valid,
  output mem,
  output cond_valid
);
  wire rr;
  wire ri6;
  wire rrc;
  wire ric;
  wire ri8;
  wire i12;
  wire s0;
  wire s1;
  wire [4:0] s2;
  wire [4:0] s3;
  wire [4:0] s4;
  wire [4:0] s5;
  wire [4:0] s6;
  wire [4:0] s7;
  wire s8;
  wire mem_temp;
  Decoder3 Decoder3_i0 (
    .sel( fmt ),
    .out_0( rr ),
    .out_1( ri6 ),
    .out_2( rrc ),
    .out_3( ric ),
    .out_4( ri8 ),
    .out_5( i12 ),
    .out_6( s0 ),
    .out_7( s1 )
  );
  assign s7[0] = fmt[0];
  assign s7[4:1] = 4'b1111;
  assign s2[2:0] = op0[2:0];
  assign s2[4:3] = 2'b10;
  assign s8 = op0[0];
  assign s6[0] = s8;
  assign s6[4:1] = 4'b1110;
  assign mem_temp = (s0 | s1);
  assign s3[0] = s8;
  assign s3[4:1] = 4'b1100;
  assign s4[0] = s8;
  assign s4[4:1] = 4'b1100;
  assign s5[0] = s8;
  assign s5[4:1] = 4'b1101;
  assign rd_valid = ~ i12;
  assign cond_valid = (ric | rrc);
  Mux_8x1_NBits #(
    .Bits(5)
  )
  Mux_8x1_NBits_i1 (
    .sel( fmt ),
    .in_0( op0 ),
    .in_1( s2 ),
    .in_2( s3 ),
    .in_3( s4 ),
    .in_4( s5 ),
    .in_5( s6 ),
    .in_6( s7 ),
    .in_7( s7 ),
    .out( op )
  );
  assign rs_valid = (mem_temp | rrc | rr);
  assign imm_valid = ~ (rr | rrc | mem_temp);
  assign mem = mem_temp;
endmodule
module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule




module decoder (
  input [15:0] rdval,
  input [15:0] rsval,
  input [15:0] instr,
  output [3:0] rs,
  output [3:0] rd,
  output [15:0] L,
  output [15:0] R,
  output [2:0] cond,
  output [4:0] op,
  output rs_valid,
  output rd_valid,
  output [15:0] imm,
  output immv
);
  wire [2:0] fmt;
  wire [4:0] op0;
  wire rd_valid_temp;
  wire rs_valid_temp;
  wire imm_valid;
  wire mem;
  wire cond_valid;
  wire [3:0] rs_i;
  wire [3:0] rd_i;
  wire [2:0] s0;
  wire [4:0] s1;
  wire [5:0] s2;
  wire [7:0] s3;
  wire [11:0] s4;
  wire [15:0] imm12;
  wire [15:0] imm6;
  wire [15:0] s5;
  wire [15:0] imm_temp;
  wire [15:0] imm8;
  wire [15:0] imm5;
  wire [15:0] off5;
  assign fmt = instr[2:0];
  assign op0 = instr[7:3];
  assign rs_i = instr[11:8];
  assign rd_i = instr[15:12];
  assign s0 = instr[6:4];
  assign s1 = instr[11:7];
  assign s2 = instr[11:6];
  assign s3 = instr[11:4];
  assign s4 = instr[15:4];
  instdecoder instdecoder_i0 (
    .fmt( fmt ),
    .op0( op0 ),
    .op( op ),
    .rd_valid( rd_valid_temp ),
    .rs_valid( rs_valid_temp ),
    .imm_valid( imm_valid ),
    .mem( mem ),
    .cond_valid( cond_valid )
  );
  DIG_BitExtender #(
    .inputBits(12),
    .outputBits(16)
  )
  DIG_BitExtender_i1 (
    .in( s4 ),
    .out( imm12 )
  );
  DIG_BitExtender #(
    .inputBits(6),
    .outputBits(16)
  )
  DIG_BitExtender_i2 (
    .in( s2 ),
    .out( imm6 )
  );
  DIG_BitExtender #(
    .inputBits(8),
    .outputBits(16)
  )
  DIG_BitExtender_i3 (
    .in( s3 ),
    .out( imm8 )
  );
  DIG_BitExtender #(
    .inputBits(5),
    .outputBits(16)
  )
  DIG_BitExtender_i4 (
    .in( s1 ),
    .out( imm5 )
  );
  assign off5[4:0] = op0;
  assign off5[15:5] = 11'b0;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i5 (
    .sel( rs_valid_temp ),
    .in_0( 16'b0 ),
    .in_1( rsval ),
    .out( s5 )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i6 (
    .sel( rd_valid_temp ),
    .in_0( 4'b0 ),
    .in_1( rd_i ),
    .out( rd )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i7 (
    .sel( rs_valid_temp ),
    .in_0( 4'b0 ),
    .in_1( rs_i ),
    .out( rs )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i8 (
    .sel( fmt ),
    .in_0( 16'b0 ),
    .in_1( imm6 ),
    .in_2( 16'b0 ),
    .in_3( imm5 ),
    .in_4( imm8 ),
    .in_5( imm12 ),
    .in_6( off5 ),
    .in_7( off5 ),
    .out( imm_temp )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i9 (
    .sel( cond_valid ),
    .in_0( 3'b0 ),
    .in_1( s0 ),
    .out( cond )
  );
  assign immv = (imm_valid | mem);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i10 (
    .sel( imm_valid ),
    .in_0( s5 ),
    .in_1( imm_temp ),
    .out( R )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i11 (
    .sel( mem ),
    .in_0( rdval ),
    .in_1( imm_temp ),
    .out( L )
  );
  assign rs_valid = rs_valid_temp;
  assign rd_valid = rd_valid_temp;
  assign imm = imm_temp;
endmodule

module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module execute (
  input [15:0] L,
  input [15:0] R,
  input [2:0] cond,
  input [2:0] op,
  output [15:0] result,
  output skip_n
);
  wire [15:0] s0;
  wire s1;
  wire [15:0] s2;
  wire s3;
  wire [1:0] s4;
  wire eq;
  wire ne;
  wire lt;
  wire ge;
  wire lo;
  wire hs;
  wire s5;
  wire s6;
  wire s7;
  wire [15:0] s8;
  wire [7:0] s9;
  wire [15:0] s10;
  wire [3:0] s11;
  wire [1:0] s12;
  Decoder3 Decoder3_i0 (
    .sel( cond ),
    .out_1( eq ),
    .out_2( ne ),
    .out_3( lt ),
    .out_4( ge ),
    .out_5( lo ),
    .out_6( hs )
  );
  // signed
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i1 (
    .a( L ),
    .b( R ),
    .\> ( s5 ),
    .\= ( s6 ),
    .\< ( s7 )
  );
  assign s8 = ~ R;
  assign s10 = (L ^ R);
  assign s1 = op[2];
  assign s4 = op[1:0];
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( s1 ),
    .in_0( R ),
    .in_1( s8 ),
    .out( s0 )
  );
  assign s9 = ~ (s10[7:0] | s10[15:8]);
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i3 (
    .a( L ),
    .b( s0 ),
    .c_i( s1 ),
    .s( s2 ),
    .c_o( s3 )
  );
  assign s11 = (s9[3:0] & s9[7:4]);
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i4 (
    .sel( s4 ),
    .in_0( L ),
    .in_1( s2 ),
    .in_2( 16'b0 ),
    .in_3( s0 ),
    .out( result )
  );
  assign s12 = (s11[1:0] & s11[3:2]);
  assign skip_n = ((lt & (s5 | s6)) | (ge & s7) | (lo & s3) | (hs & ~ s3) | (ne & (s12[0] & s12[1])) | (eq & ~ (s12[0] & s12[1])));
endmodule

module DemuxBus2 #(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out_0,
    output [(Bits-1):0] out_1,
    output [(Bits-1):0] out_2,
    output [(Bits-1):0] out_3,
    input [1:0] sel,
    input [(Bits-1):0] in
);
    assign out_0 = (sel == 2'h0)? in : 'd0;
    assign out_1 = (sel == 2'h1)? in : 'd0;
    assign out_2 = (sel == 2'h2)? in : 'd0;
    assign out_3 = (sel == 2'h3)? in : 'd0;
endmodule


module regfile (
  input [1:0] rs,
  input [1:0] rd,
  input [15:0] result,
  input clock,
  input en,
  output [15:0] rdval,
  output [15:0] rsval,
  output [15:0] R0,
  output [15:0] R1,
  output [15:0] R2,
  output [15:0] R3
);
  wire [1:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire s5;
  wire [15:0] R0_temp;
  wire s6;
  wire [15:0] R1_temp;
  wire s7;
  wire [15:0] R2_temp;
  wire s8;
  wire [15:0] R3_temp;
  wire [1:0] s9;
  wire [2:0] s10;
  assign s9 = rs[1:0];
  assign s0 = rd[1:0];
  DemuxBus2 #(
    .Bits(16)
  )
  DemuxBus2_i0 (
    .sel( s0 ),
    .in( result ),
    .out_0( s1 ),
    .out_1( s2 ),
    .out_2( s3 ),
    .out_3( s4 )
  );
  assign s10[1:0] = s0;
  assign s10[2] = en;
  Decoder3 Decoder3_i1 (
    .sel( s10 ),
    .out_4( s5 ),
    .out_5( s6 ),
    .out_6( s7 ),
    .out_7( s8 )
  );
  // R0
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( s1 ),
    .C( clock ),
    .en( s5 ),
    .Q( R0_temp )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s2 ),
    .C( clock ),
    .en( s6 ),
    .Q( R1_temp )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( s3 ),
    .C( clock ),
    .en( s7 ),
    .Q( R2_temp )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( s4 ),
    .C( clock ),
    .en( s8 ),
    .Q( R3_temp )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i6 (
    .sel( s9 ),
    .in_0( R0_temp ),
    .in_1( R1_temp ),
    .in_2( R2_temp ),
    .in_3( R3_temp ),
    .out( rsval )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i7 (
    .sel( s0 ),
    .in_0( R0_temp ),
    .in_1( R1_temp ),
    .in_2( R2_temp ),
    .in_3( R3_temp ),
    .out( rdval )
  );
  assign R0 = R0_temp;
  assign R1 = R1_temp;
  assign R2 = R2_temp;
  assign R3 = R3_temp;
endmodule

module rj32 (
  input clock,
  input step,
  input run_slow,
  input [15:0] D_prog,
  input [15:0] D_in,
  input run_fast,
  input run_faster,
  output [15:0] R0,
  output [15:0] R1,
  output [15:0] R2,
  output [15:0] R3,
  output [7:0] PC,
  output halt,
  output error,
  output skip,
  output rd_valid,
  output rs_valid,
  output [4:0] op,
  output [2:0] cond,
  output stall,
  output [15:0] L,
  output [15:0] R,
  output [3:0] rd,
  output [3:0] rs,
  output jump,
  output [7:0] A_prog,
  output clock_m,
  output [13:0] A_data,
  output [15:0] D_out,
  output w_en,
  output [15:0] result,
  output immv,
  output [15:0] imm
);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [3:0] rs_temp;
  wire [3:0] rd_temp;
  wire [15:0] L_temp;
  wire [15:0] R_temp;
  wire [2:0] cond_temp;
  wire [4:0] op_temp;
  wire [2:0] s3;
  wire [15:0] s4;
  wire s5;
  wire [15:0] result_temp;
  wire en;
  wire [7:0] A_prog_temp;
  wire s6;
  wire jump_temp;
  wire stall_temp;
  wire s7;
  wire s8;
  clockctrl clockctrl_i0 (
    .clock( clock ),
    .step( step ),
    .slow( run_slow ),
    .fast( run_fast ),
    .faster( run_faster ),
    .stall( stall_temp )
  );
  assign clock_m = ~ clock;
  fetch fetch_i1 (
    .instr_i( D_prog ),
    .clock( clock ),
    .fetch( s6 ),
    .jump( jump_temp ),
    .value( R_temp ),
    .en( en ),
    .instr_o( s2 ),
    .pc( A_prog_temp )
  );
  control control_i2 (
    .op( op_temp ),
    .stall( stall_temp ),
    .clock( clock ),
    .skip_n( s5 ),
    .aluop( s3 ),
    .skip( skip ),
    .halt( halt ),
    .error( error ),
    .en_write( en ),
    .mem( s7 ),
    .store( s8 ),
    .en_fetch( s6 ),
    .jump( jump_temp )
  );
  memaccess memaccess_i3 (
    .result( s4 ),
    .rdval( s0 ),
    .mem( s7 ),
    .memop( s8 ),
    .D( D_in ),
    .en( en ),
    .wrval( result_temp ),
    .A( A_data ),
    .str( w_en ),
    .D_in( D_out )
  );
  decoder decoder_i4 (
    .rdval( s0 ),
    .rsval( s1 ),
    .instr( s2 ),
    .rs( rs_temp ),
    .rd( rd_temp ),
    .L( L_temp ),
    .R( R_temp ),
    .cond( cond_temp ),
    .op( op_temp ),
    .rs_valid( rs_valid ),
    .rd_valid( rd_valid ),
    .imm( imm ),
    .immv( immv )
  );
  execute execute_i5 (
    .L( L_temp ),
    .R( R_temp ),
    .cond( cond_temp ),
    .op( s3 ),
    .result( s4 ),
    .skip_n( s5 )
  );
  regfile regfile_i6 (
    .rs( rs_temp ),
    .rd( rd_temp ),
    .result( result_temp ),
    .clock( clock ),
    .en( en ),
    .rdval( s0 ),
    .rsval( s1 ),
    .R0( R0 ),
    .R1( R1 ),
    .R2( R2 ),
    .R3( R3 )
  );
  assign PC = A_prog_temp;
  assign op = op_temp;
  assign cond = cond_temp;
  assign stall = stall_temp;
  assign L = L_temp;
  assign R = R_temp;
  assign rd = rd_temp;
  assign rs = rs_temp;
  assign jump = jump_temp;
  assign A_prog = A_prog_temp;
  assign result = result_temp;
endmodule
