/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module clockctrl (
  input clock,
  input step,
  input run,
  output stall
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( step ),
    .C( clock ),
    .Q( s3 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( s3 ),
    .C( clock ),
    .\~Q ( s4 )
  );
  assign s2 = (s3 & s4);
  assign s0 = (s1 | s2);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( s5 ),
    .C( clock ),
    .Clr( s2 ),
    .Q( s1 )
  );
  assign s5 = (s1 | run);
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i3 (
    .D( s0 ),
    .C( clock ),
    .\~Q ( stall )
  );
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module fetch (
  input [15:0] instr_i,
  input clock,
  input en,
  input jump,
  input [15:0] value,
  output [7:0] pc,
  output [15:0] instr_o
);
  wire [7:0] s0;
  wire s1;
  wire [15:0] s2;
  assign s1 = (en & jump);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i0 (
    .sel( jump ),
    .in_0( instr_i ),
    .in_1( 16'b0 ),
    .out( s2 )
  );
  assign s0 = value[7:0];
  // PC
  DIG_CounterPreset #(
    .Bits(8),
    .maxValue(0)
  )
  DIG_CounterPreset_i1 (
    .en( en ),
    .C( clock ),
    .dir( 1'b0 ),
    .in( s0 ),
    .ld( s1 ),
    .clr( 1'b0 ),
    .out( pc )
  );
  // IR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( s2 ),
    .C( clock ),
    .en( en ),
    .Q( instr_o )
  );
endmodule

module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module control (
  input sys,
  input [4:0] op,
  input stall,
  input clock,
  input t_in,
  output [2:0] aluop,
  output T,
  output halt,
  output error,
  output en_write,
  output mem,
  output [1:0] memop,
  output en_fetch,
  output jump
);
  wire s0;
  wire [1:0] s1;
  wire [2:0] s2;
  wire T_temp;
  wire en_fetch_temp;
  wire s3;
  wire s4;
  wire s5;
  wire mem_temp;
  wire [1:0] s6;
  assign s0 = (op[2] & ~ op[3] & ~ op[4]);
  assign s4 = (op[1] & op[2] & ~ op[3] & ~ op[4]);
  assign mem_temp = (~ sys & ~ op[4] & ~ op[3] & ~ op[2]);
  assign en_fetch_temp = ~ stall;
  assign s2 = op[2:0];
  assign s6 = op[1:0];
  // T
  DIG_Register DIG_Register_i0 (
    .D( t_in ),
    .C( clock ),
    .en( en_fetch_temp ),
    .Q( T_temp )
  );
  assign s5 = (op[0] & ~ op[1] & sys & en_fetch_temp);
  Mux_2x1_NBits #(
    .Bits(2)
  )
  Mux_2x1_NBits_i1 (
    .sel( mem_temp ),
    .in_0( 2'b0 ),
    .in_1( s6 ),
    .out( memop )
  );
  assign s1[0] = (~ op[3] & op[4] & ~ sys);
  assign s1[1] = mem_temp;
  Mux_4x1_NBits #(
    .Bits(3)
  )
  Mux_4x1_NBits_i2 (
    .sel( s1 ),
    .in_0( 3'b111 ),
    .in_1( s2 ),
    .in_2( 3'b0 ),
    .in_3( 3'b0 ),
    .out( aluop )
  );
  assign s3 = (op[0] ^ T_temp);
  assign halt = (T_temp & s5);
  assign error = (s5 & ~ T_temp);
  Mux_2x1 Mux_2x1_i3 (
    .sel( s4 ),
    .in_0( s0 ),
    .in_1( s3 ),
    .out( jump )
  );
  assign T = T_temp;
  assign en_write = en_fetch_temp;
  assign mem = mem_temp;
  assign en_fetch = en_fetch_temp;
endmodule

module memaccess (
  input [15:0] result,
  input [15:0] rdval,
  input mem,
  input [1:0] memop,
  input [15:0] D,
  input en,
  output [15:0] wrval,
  output [13:0] A,
  output str,
  output [15:0] D_in
);
  wire [1:0] s0;
  wire s1;
  assign s1 = memop[0];
  assign A = result[13:0];
  assign s0[0] = s1;
  assign s0[1] = mem;
  assign str = (s1 & mem & en);
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i0 (
    .sel( s0 ),
    .in_0( result ),
    .in_1( result ),
    .in_2( D ),
    .in_3( rdval ),
    .out( wrval )
  );
  assign D_in = rdval;
endmodule

module Decoder3 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    input [2:0] sel
);
    assign out_0 = (sel == 3'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 3'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 3'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 3'h3)? 1'b1 : 1'b0;
    assign out_4 = (sel == 3'h4)? 1'b1 : 1'b0;
    assign out_5 = (sel == 3'h5)? 1'b1 : 1'b0;
    assign out_6 = (sel == 3'h6)? 1'b1 : 1'b0;
    assign out_7 = (sel == 3'h7)? 1'b1 : 1'b0;
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module instdecoder (
  input [2:0] fmt,
  input [1:0] op1,
  input [3:0] op2,
  input [4:0] op3,
  output [4:0] op,
  output tworeg,
  output sys,
  output imm5_valid,
  output imm11_valid,
  output rs_valid,
  output rd_valid
);
  wire sys_temp;
  wire i11;
  wire rr;
  wire ri;
  wire [4:0] s0;
  wire [4:0] s1;
  wire [4:0] s2;
  wire ls;
  Decoder3 Decoder3_i0 (
    .sel( fmt ),
    .out_0( sys_temp ),
    .out_1( i11 ),
    .out_2( rr ),
    .out_3( ri )
  );
  assign s0[1:0] = op1;
  assign s0[4:2] = fmt;
  assign s1[3:0] = op2;
  assign s1[4] = 1'b1;
  assign s2[1:0] = fmt[1:0];
  assign s2[4:2] = 3'b0;
  assign ls = fmt[2];
  Mux_8x1_NBits #(
    .Bits(5)
  )
  Mux_8x1_NBits_i1 (
    .sel( fmt ),
    .in_0( s0 ),
    .in_1( s0 ),
    .in_2( op3 ),
    .in_3( s1 ),
    .in_4( s2 ),
    .in_5( s2 ),
    .in_6( s2 ),
    .in_7( s2 ),
    .out( op )
  );
  assign imm5_valid = (ri | ls);
  assign imm11_valid = (sys_temp | i11);
  assign rs_valid = (ls | rr);
  assign rd_valid = ~ (sys_temp | i11);
  assign tworeg = (rr | ls);
  assign sys = sys_temp;
endmodule
module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule




module decoder (
  input [15:0] rdval,
  input [15:0] rsval,
  input mem,
  input [15:0] instr,
  output [1:0] rs,
  output [1:0] rd,
  output [15:0] L,
  output [15:0] R,
  output sys,
  output [4:0] op,
  output rs_valid,
  output rd_valid
);
  wire [2:0] fmt;
  wire [1:0] op1;
  wire [3:0] s0;
  wire [4:0] op3;
  wire tworeg;
  wire imm11_valid;
  wire rs_valid_temp;
  wire rd_valid_temp;
  wire [3:0] rd_i;
  wire [10:0] s1;
  wire [15:0] imm5;
  wire [15:0] imm11;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [3:0] s4;
  wire [3:0] s5;
  wire [15:0] s6;
  assign fmt = instr[2:0];
  assign op1 = instr[4:3];
  assign rd_i = instr[6:3];
  assign s0 = instr[10:7];
  assign op3 = instr[15:11];
  assign s1 = instr[15:5];
  instdecoder instdecoder_i0 (
    .fmt( fmt ),
    .op1( op1 ),
    .op2( s0 ),
    .op3( op3 ),
    .op( op ),
    .tworeg( tworeg ),
    .sys( sys ),
    .imm11_valid( imm11_valid ),
    .rs_valid( rs_valid_temp ),
    .rd_valid( rd_valid_temp )
  );
  DIG_BitExtender #(
    .inputBits(5),
    .outputBits(16)
  )
  DIG_BitExtender_i1 (
    .in( op3 ),
    .out( imm5 )
  );
  DIG_BitExtender #(
    .inputBits(11),
    .outputBits(16)
  )
  DIG_BitExtender_i2 (
    .in( s1 ),
    .out( imm11 )
  );
  assign s6[4:0] = op3;
  assign s6[15:5] = 11'b0;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i3 (
    .sel( rs_valid_temp ),
    .in_0( 16'b0 ),
    .in_1( rsval ),
    .out( s3 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i4 (
    .sel( imm11_valid ),
    .in_0( imm5 ),
    .in_1( imm11 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i5 (
    .sel( rd_valid_temp ),
    .in_0( 4'b0 ),
    .in_1( rd_i ),
    .out( s4 )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i6 (
    .sel( rs_valid_temp ),
    .in_0( 4'b0 ),
    .in_1( s0 ),
    .out( s5 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i7 (
    .sel( mem ),
    .in_0( rdval ),
    .in_1( s6 ),
    .out( L )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i8 (
    .sel( tworeg ),
    .in_0( s2 ),
    .in_1( s3 ),
    .out( R )
  );
  assign rd = s4[1:0];
  assign rs = s5[1:0];
  assign rs_valid = rs_valid_temp;
  assign rd_valid = rd_valid_temp;
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module execute (
  input [15:0] L,
  input [15:0] R,
  input [2:0] op,
  output [15:0] result,
  output t_in
);
  wire [15:0] s0;
  wire eq;
  wire s1;
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i0 (
    .a( L ),
    .b( R ),
    .c_i( 1'b0 ),
    .s( s0 )
  );
  Decoder3 Decoder3_i1 (
    .sel( op ),
    .out_4( eq )
  );
  // eq
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i2 (
    .a( R ),
    .b( L ),
    .\= ( s1 )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i3 (
    .sel( op ),
    .in_0( s0 ),
    .in_1( 16'b0 ),
    .in_2( 16'b0 ),
    .in_3( 16'b0 ),
    .in_4( L ),
    .in_5( L ),
    .in_6( R ),
    .in_7( L ),
    .out( result )
  );
  assign t_in = (eq & s1);
endmodule

module DemuxBus2 #(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out_0,
    output [(Bits-1):0] out_1,
    output [(Bits-1):0] out_2,
    output [(Bits-1):0] out_3,
    input [1:0] sel,
    input [(Bits-1):0] in
);
    assign out_0 = (sel == 2'h0)? in : 'd0;
    assign out_1 = (sel == 2'h1)? in : 'd0;
    assign out_2 = (sel == 2'h2)? in : 'd0;
    assign out_3 = (sel == 2'h3)? in : 'd0;
endmodule


module regfile (
  input [1:0] rs,
  input [1:0] rd,
  input [15:0] result,
  input clock,
  input en,
  output [15:0] rdval,
  output [15:0] rsval,
  output [15:0] R0,
  output [15:0] R1,
  output [15:0] R2,
  output [15:0] R3
);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire s4;
  wire [15:0] R0_temp;
  wire s5;
  wire [15:0] R1_temp;
  wire s6;
  wire [15:0] R2_temp;
  wire s7;
  wire [15:0] R3_temp;
  wire [2:0] s8;
  DemuxBus2 #(
    .Bits(16)
  )
  DemuxBus2_i0 (
    .sel( rd ),
    .in( result ),
    .out_0( s0 ),
    .out_1( s1 ),
    .out_2( s2 ),
    .out_3( s3 )
  );
  assign s8[1:0] = rd;
  assign s8[2] = en;
  Decoder3 Decoder3_i1 (
    .sel( s8 ),
    .out_4( s4 ),
    .out_5( s5 ),
    .out_6( s6 ),
    .out_7( s7 )
  );
  // R0
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( s0 ),
    .C( clock ),
    .en( s4 ),
    .Q( R0_temp )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s1 ),
    .C( clock ),
    .en( s5 ),
    .Q( R1_temp )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( s2 ),
    .C( clock ),
    .en( s6 ),
    .Q( R2_temp )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( s3 ),
    .C( clock ),
    .en( s7 ),
    .Q( R3_temp )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i6 (
    .sel( rs ),
    .in_0( R0_temp ),
    .in_1( R1_temp ),
    .in_2( R2_temp ),
    .in_3( R3_temp ),
    .out( rsval )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i7 (
    .sel( rd ),
    .in_0( R0_temp ),
    .in_1( R1_temp ),
    .in_2( R2_temp ),
    .in_3( R3_temp ),
    .out( rdval )
  );
  assign R0 = R0_temp;
  assign R1 = R1_temp;
  assign R2 = R2_temp;
  assign R3 = R3_temp;
endmodule

module rj32 (
  input clock,
  input step,
  input run,
  input [15:0] D_prog,
  input [15:0] D_in,
  output [15:0] R0,
  output [15:0] R1,
  output [15:0] R2,
  output [15:0] R3,
  output [7:0] PC,
  output halt,
  output error,
  output T_o,
  output rd_valid,
  output rs_valid,
  output [4:0] op,
  output sys,
  output stall,
  output [15:0] L,
  output [15:0] R,
  output [1:0] rd,
  output [1:0] rs,
  output jump,
  output [7:0] A_prog,
  output clock_m,
  output [13:0] A_data,
  output [15:0] D_out,
  output w_en
);
  wire [15:0] s0;
  wire [15:0] s1;
  wire s2;
  wire [15:0] s3;
  wire [1:0] rs_temp;
  wire [1:0] rd_temp;
  wire [15:0] L_temp;
  wire [15:0] R_temp;
  wire sys_temp;
  wire [4:0] op_temp;
  wire [2:0] s4;
  wire [15:0] s5;
  wire s6;
  wire [15:0] s7;
  wire en;
  wire [7:0] A_prog_temp;
  wire s8;
  wire jump_temp;
  wire stall_temp;
  wire [1:0] s9;
  clockctrl clockctrl_i0 (
    .clock( clock ),
    .step( step ),
    .run( run ),
    .stall( stall_temp )
  );
  assign clock_m = ~ clock;
  fetch fetch_i1 (
    .instr_i( D_prog ),
    .clock( clock ),
    .en( s8 ),
    .jump( jump_temp ),
    .value( R_temp ),
    .pc( A_prog_temp ),
    .instr_o( s3 )
  );
  control control_i2 (
    .sys( sys_temp ),
    .op( op_temp ),
    .stall( stall_temp ),
    .clock( clock ),
    .t_in( s6 ),
    .aluop( s4 ),
    .T( T_o ),
    .halt( halt ),
    .error( error ),
    .en_write( en ),
    .mem( s2 ),
    .memop( s9 ),
    .en_fetch( s8 ),
    .jump( jump_temp )
  );
  memaccess memaccess_i3 (
    .result( s5 ),
    .rdval( s0 ),
    .mem( s2 ),
    .memop( s9 ),
    .D( D_in ),
    .en( en ),
    .wrval( s7 ),
    .A( A_data ),
    .str( w_en ),
    .D_in( D_out )
  );
  decoder decoder_i4 (
    .rdval( s0 ),
    .rsval( s1 ),
    .mem( s2 ),
    .instr( s3 ),
    .rs( rs_temp ),
    .rd( rd_temp ),
    .L( L_temp ),
    .R( R_temp ),
    .sys( sys_temp ),
    .op( op_temp ),
    .rs_valid( rs_valid ),
    .rd_valid( rd_valid )
  );
  execute execute_i5 (
    .L( L_temp ),
    .R( R_temp ),
    .op( s4 ),
    .result( s5 ),
    .t_in( s6 )
  );
  regfile regfile_i6 (
    .rs( rs_temp ),
    .rd( rd_temp ),
    .result( s7 ),
    .clock( clock ),
    .en( en ),
    .rdval( s0 ),
    .rsval( s1 ),
    .R0( R0 ),
    .R1( R1 ),
    .R2( R2 ),
    .R3( R3 )
  );
  assign PC = A_prog_temp;
  assign op = op_temp;
  assign sys = sys_temp;
  assign stall = stall_temp;
  assign L = L_temp;
  assign R = R_temp;
  assign rd = rd_temp;
  assign rs = rs_temp;
  assign jump = jump_temp;
  assign A_prog = A_prog_temp;
endmodule
